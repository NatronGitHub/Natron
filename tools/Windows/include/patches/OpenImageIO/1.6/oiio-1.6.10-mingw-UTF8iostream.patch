diff --git a/src/include/OpenImageIO/filesystem.h b/src/include/OpenImageIO/filesystem.h
index 78732f2..b4c6c38 100644
--- a/src/include/OpenImageIO/filesystem.h
+++ b/src/include/OpenImageIO/filesystem.h
@@ -45,6 +45,7 @@
 #include <cstdio>
 #include <ctime>
 #include <fstream>
+#include <cassert>
 #include <string>
 #include <vector>
 
@@ -52,9 +53,25 @@
 #include "oiioversion.h"
 #include "string_view.h"
 
+#if defined(_WIN32) && defined(__GLIBCXX__)
+#define FILESYSTEM_USE_STDIO_FILEBUF 1
+#include "fstream_mingw.h"
+#endif
 
 OIIO_NAMESPACE_BEGIN
 
+#if FILESYSTEM_USE_STDIO_FILEBUF
+// MingW uses GCC to build, but does not support having a wchar_t* passed as argument
+// of ifstream::open or ofstream::open. To properly support UTF-8 encoding on MingW we must
+// use the __gnu_cxx::stdio_filebuf GNU extension that can be used with _wfsopen and returned
+// into a istream which share the same API as ifsteam. The same reasoning holds for ofstream.
+typedef basic_ifstream<char> ifstream;
+typedef basic_ofstream<char> ofstream;
+#else
+typedef std::ifstream ifstream;
+typedef std::ofstream ofstream;
+#endif
+
 /// @namespace Filesystem
 ///
 /// @brief Platform-independent utilities for manipulating file names,
@@ -192,16 +209,16 @@ OIIO_API FILE *fopen (string_view path, string_view mode);
 /// Return the current (".") directory path.
 ///
 OIIO_API std::string current_path ();
-
+    
 /// Version of std::ifstream.open that can handle UTF-8 paths
 ///
-OIIO_API void open (std::ifstream &stream, string_view path,
-                    std::ios_base::openmode mode = std::ios_base::in);
-
+OIIO_API void open (OIIO_NAMESPACE::ifstream &stream, string_view path,
+                        std::ios_base::openmode mode = std::ios_base::in);
+    
 /// Version of std::ofstream.open that can handle UTF-8 paths
 ///
-OIIO_API void open (std::ofstream &stream, string_view path,
-                    std::ios_base::openmode mode = std::ios_base::out);
+OIIO_API void open (OIIO_NAMESPACE::ofstream &stream, string_view path,
+                        std::ios_base::openmode mode = std::ios_base::out);
 
 /// Read the entire contents of the named text file and place it in str,
 /// returning true on success, false on failure.
diff --git a/src/include/OpenImageIO/fstream_mingw.h b/src/include/OpenImageIO/fstream_mingw.h
new file mode 100644
index 0000000..df5fbe2
--- /dev/null
+++ b/src/include/OpenImageIO/fstream_mingw.h
@@ -0,0 +1,352 @@
+/*
+  Copyright 2008 Larry Gritz and the other authors and contributors.
+  All Rights Reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are
+  met:
+  * Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+  * Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+  * Neither the name of the software's owners nor the names of its
+    contributors may be used to endorse or promote products derived from
+    this software without specific prior written permission.
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+  (This is the Modified BSD License)
+*/
+
+
+/// @file  fstream_mingw.h
+///
+/// @brief Utilities for dealing with fstream on MingW.
+/// Basically accepting wchar_t* filenames in the std::ifstream::open function
+/// is a Windows MSVC extension and does not work on MingW. This file implements
+/// ifstream and ofstream so that they work with UTF-16 filenames.
+
+
+#ifndef OPENIMAGEIO_FSTREAM_MINGW_H
+#define OPENIMAGEIO_FSTREAM_MINGW_H
+
+#include <cassert>
+#include <istream>
+#include <ostream>
+
+#if defined(_WIN32) && defined(__GLIBCXX__)
+#include <ext/stdio_filebuf.h> // __gnu_cxx::stdio_filebuf
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <Share.h>
+
+
+OIIO_NAMESPACE_BEGIN
+
+
+template <class _CharT, class _Traits = std::char_traits<_CharT> >
+class basic_ifstream
+: public std::basic_istream<_CharT, _Traits>
+{
+public:
+    typedef _CharT                         char_type;
+    typedef _Traits                        traits_type;
+    typedef typename traits_type::int_type int_type;
+    typedef typename traits_type::pos_type pos_type;
+    typedef typename traits_type::off_type off_type;
+    
+    typedef typename __gnu_cxx::stdio_filebuf<char_type, traits_type> stdio_filebuf;
+
+    
+    basic_ifstream();
+    explicit basic_ifstream(const std::wstring& path, std::ios_base::openmode __mode = std::ios_base::in);
+    
+    virtual ~basic_ifstream();
+    
+    stdio_filebuf* rdbuf() const;
+    bool is_open() const;
+    void open(const std::wstring& path, std::ios_base::openmode __mode = std::ios_base::in);
+    void close();
+    
+private:
+    
+    void open_internal(const std::wstring& path, std::ios_base::openmode mode);
+    
+    stdio_filebuf* __sb_;
+};
+
+template <class _CharT, class _Traits>
+inline
+basic_ifstream<_CharT, _Traits>::basic_ifstream()
+: std::basic_istream<char_type, traits_type>(0)
+, __sb_(0)
+{
+}
+
+
+template <class _CharT, class _Traits>
+inline
+basic_ifstream<_CharT, _Traits>::basic_ifstream(const std::wstring& path, std::ios_base::openmode __mode)
+: std::basic_istream<char_type, traits_type>(0)
+, __sb_(0)
+{
+    open_internal(path, __mode | std::ios_base::in);
+}
+
+template <class _CharT, class _Traits>
+inline
+basic_ifstream<_CharT, _Traits>::~basic_ifstream()
+{
+    delete __sb_;
+}
+
+
+inline int
+ios_open_mode_to_oflag(std::ios_base::openmode mode)
+{
+    int f = 0;
+    if (mode & std::ios_base::in) {
+        f |= _O_RDONLY;
+    }
+    if (mode & std::ios_base::out) {
+        f |= _O_WRONLY;
+        f |= _O_CREAT;
+        if (mode & std::ios_base::app) {
+            f |= _O_APPEND;
+        }
+        if (mode & std::ios_base::trunc) {
+            f |= _O_TRUNC;
+        }
+    }
+    if (mode & std::ios_base::binary) {
+        f |= _O_BINARY;
+    } else {
+        f |= _O_TEXT;
+    }
+    return f;
+}
+
+template <class _CharT, class _Traits>
+inline
+void
+basic_ifstream<_CharT, _Traits>::open_internal(const std::wstring& path, std::ios_base::openmode mode)
+{
+	if (is_open()) {
+		// if the stream is already associated with a file (i.e., it is already open), calling this function fails.
+		this->setstate(std::ios_base::failbit);
+        return;
+	}
+    int fd;
+    int oflag = ios_open_mode_to_oflag(mode);
+    errno_t errcode = _wsopen_s(&fd, path.c_str(), oflag, _SH_DENYNO, _S_IREAD | _S_IWRITE);
+    if (errcode != 0) {
+        this->setstate(std::ios_base::failbit);
+        return;
+    }
+    __sb_ = new stdio_filebuf(fd, mode, 1);
+    if (__sb_ == 0) {
+        this->setstate(std::ios_base::failbit);
+        return;
+    }
+	// 409. Closing an fstream should clear error state
+    this->clear();
+	assert(__sb_);
+	
+	// In init() the rdstate() is set to badbit if __sb_ is NULL and
+	// goodbit otherwise. The assert afterwards ensures this.
+    this->init(__sb_);
+	assert(this->good() && !this->fail());
+}
+
+template <class _CharT, class _Traits>
+inline
+typename basic_ifstream<_CharT, _Traits>::stdio_filebuf*
+basic_ifstream<_CharT, _Traits>::rdbuf() const
+{
+    return const_cast<stdio_filebuf*>(__sb_);
+}
+
+
+template <class _CharT, class _Traits>
+inline
+bool
+basic_ifstream<_CharT, _Traits>::is_open() const
+{
+    return __sb_ && __sb_->is_open();
+}
+
+
+template <class _CharT, class _Traits>
+void
+basic_ifstream<_CharT, _Traits>::open(const std::wstring& path, std::ios_base::openmode __mode)
+{
+    open_internal(path, __mode | std::ios_base::in);
+}
+
+template <class _CharT, class _Traits>
+inline
+void
+basic_ifstream<_CharT, _Traits>::close()
+{
+    if (!__sb_) {
+        return;
+    }
+    if (__sb_->close() == 0)
+        this->setstate(std::ios_base::failbit);
+    
+    delete __sb_;
+	__sb_= 0;
+
+}
+
+
+
+template <class _CharT, class _Traits = std::char_traits<_CharT> >
+class basic_ofstream
+: public std::basic_ostream<_CharT, _Traits>
+{
+public:
+    typedef _CharT                         char_type;
+    typedef _Traits                        traits_type;
+    typedef typename traits_type::int_type int_type;
+    typedef typename traits_type::pos_type pos_type;
+    typedef typename traits_type::off_type off_type;
+    
+    typedef typename __gnu_cxx::stdio_filebuf<char_type, traits_type> stdio_filebuf;
+    
+    
+    basic_ofstream();
+    explicit basic_ofstream(const std::wstring& path, std::ios_base::openmode __mode = std::ios_base::out);
+    
+    virtual ~basic_ofstream();
+    
+    stdio_filebuf* rdbuf() const;
+    bool is_open() const;
+    void open(const std::wstring& path, std::ios_base::openmode __mode = std::ios_base::out);
+    void close();
+    
+private:
+    
+    void open_internal(const std::wstring& path, std::ios_base::openmode mode);
+    
+    stdio_filebuf* __sb_;
+};
+
+template <class _CharT, class _Traits>
+inline
+basic_ofstream<_CharT, _Traits>::basic_ofstream()
+: std::basic_ostream<char_type, traits_type>(0)
+, __sb_(0)
+{
+}
+
+
+template <class _CharT, class _Traits>
+inline
+basic_ofstream<_CharT, _Traits>::basic_ofstream(const std::wstring& path, std::ios_base::openmode __mode)
+: std::basic_ostream<char_type, traits_type>(0)
+, __sb_(0)
+{
+    open_internal(path, __mode  | std::ios_base::out);
+}
+
+template <class _CharT, class _Traits>
+inline
+basic_ofstream<_CharT, _Traits>::~basic_ofstream()
+{
+    delete __sb_;
+}
+
+
+template <class _CharT, class _Traits>
+inline
+void
+basic_ofstream<_CharT, _Traits>::open_internal(const std::wstring& path, std::ios_base::openmode mode)
+{
+	if (is_open()) {
+		// if the stream is already associated with a file (i.e., it is already open), calling this function fails.
+		this->setstate(std::ios_base::failbit);
+        return;
+	}
+    int fd;
+    int oflag = ios_open_mode_to_oflag(mode);
+    errno_t errcode = _wsopen_s(&fd, path.c_str(), oflag, _SH_DENYNO, _S_IREAD | _S_IWRITE);
+    if (errcode != 0) {
+        this->setstate(std::ios_base::failbit);
+        return;
+    }
+    __sb_ = new stdio_filebuf(fd, mode, 1);
+    if (__sb_ == 0) {
+        this->setstate(std::ios_base::failbit);
+        return;
+    }
+	// 409. Closing an fstream should clear error state
+    this->clear();
+	assert(__sb_);
+	
+	// In init() the rdstate() is set to badbit if __sb_ is NULL and
+	// goodbit otherwise. The assert afterwards ensures this.
+    this->init(__sb_);
+	assert(this->good() && !this->fail());
+}
+
+
+template <class _CharT, class _Traits>
+inline
+typename basic_ofstream<_CharT, _Traits>::stdio_filebuf*
+basic_ofstream<_CharT, _Traits>::rdbuf() const
+{
+    return const_cast<stdio_filebuf*>(__sb_);
+}
+
+
+
+template <class _CharT, class _Traits>
+inline
+bool
+basic_ofstream<_CharT, _Traits>::is_open() const
+{
+    return __sb_ && __sb_->is_open();
+}
+
+
+template <class _CharT, class _Traits>
+void
+basic_ofstream<_CharT, _Traits>::open(const std::wstring& path, std::ios_base::openmode __mode)
+{
+    open_internal(path, __mode | std::ios_base::out);
+}
+
+template <class _CharT, class _Traits>
+inline 
+void
+basic_ofstream<_CharT, _Traits>::close()
+{
+    if (!__sb_) {
+        return;
+    }
+    if (__sb_->close() == 0)
+        this->setstate(std::ios_base::failbit);
+    
+    delete __sb_;
+	__sb_= 0;
+}
+// basic_fstream
+
+OIIO_NAMESPACE_END
+
+
+#endif // #if defined(_WIN32) && defined(__GLIBCXX__)
+
+
+#endif // OPENIMAGEIO_FSTREAM_MINGW_H
diff --git a/src/libutil/filesystem.cpp b/src/libutil/filesystem.cpp
index 72096a5..b6812dd 100644
--- a/src/libutil/filesystem.cpp
+++ b/src/libutil/filesystem.cpp
@@ -40,14 +40,19 @@
 #include <boost/foreach.hpp>
 #include <boost/regex.hpp>
 
+
 #include "OpenImageIO/dassert.h"
 #include "OpenImageIO/ustring.h"
 #include "OpenImageIO/filesystem.h"
+#include "OpenImageIO/refcnt.h"
 
 #ifdef _WIN32
 #include <windows.h>
 #include <shellapi.h>
 #include <direct.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <Share.h>
 #else
 #include <unistd.h>
 #endif
@@ -255,7 +260,16 @@ Filesystem::exists (const std::string &path)
 {
     bool r = false;
     try {
+#if defined(_WIN32)
+        // boost internally doesn't use MultiByteToWideChar (CP_UTF8,...
+        // to convert char* to wchar_t* because they do not know the encoding
+        // See boost::filesystem::path.hpp
+        // The only correct way to do this is to do the conversion ourselves
+        std::wstring wpath = Strutil::utf8_to_utf16(path);
+        r = boost::filesystem::exists (wpath);
+#else
         r = boost::filesystem::exists (path);
+#endif
     } catch (...) {
         r = false;
     }
@@ -269,7 +283,16 @@ Filesystem::is_directory (const std::string &path)
 {
     bool r = false;
     try {
+#if defined(_WIN32)
+        // boost internally doesn't use MultiByteToWideChar (CP_UTF8,...
+        // to convert char* to wchar_t* because they do not know the encoding
+        // See boost::filesystem::path.hpp
+        // The only correct way to do this is to do the conversion ourselves
+        std::wstring wpath = Strutil::utf8_to_utf16(path);
+        r = boost::filesystem::is_directory (wpath);
+#else
         r = boost::filesystem::is_directory (path);
+#endif
     } catch (...) {
         r = false;
     }
@@ -283,7 +306,16 @@ Filesystem::is_regular (const std::string &path)
 {
     bool r = false;
     try {
+#if defined(_WIN32)
+        // boost internally doesn't use MultiByteToWideChar (CP_UTF8,...
+        // to convert char* to wchar_t* because they do not know the encoding
+        // See boost::filesystem::path.hpp
+        // The only correct way to do this is to do the conversion ourselves
+        std::wstring wpath = Strutil::utf8_to_utf16(path);
+        r = boost::filesystem::is_regular_file (wpath);
+#else
         r = boost::filesystem::is_regular_file (path);
+#endif
     } catch (...) {
         r = false;
     }
@@ -295,16 +327,26 @@ Filesystem::is_regular (const std::string &path)
 bool
 Filesystem::create_directory (string_view path, std::string &err)
 {
+#if defined(_WIN32)
+    // boost internally doesn't use MultiByteToWideChar (CP_UTF8,...
+    // to convert char* to wchar_t* because they do not know the encoding
+    // See boost::filesystem::path.hpp
+    // The only correct way to do this is to do the conversion ourselves
+    std::wstring pathStr = Strutil::utf8_to_utf16(path);
+#else
+    std::string pathStr = path.str();
+#endif
+    
 #if BOOST_FILESYSTEM_VERSION >= 3
     boost::system::error_code ec;
-    bool ok = boost::filesystem::create_directory (path.str(), ec);
+    bool ok = boost::filesystem::create_directory (pathStr, ec);
     if (ok)
         err.clear();
     else
         err = ec.message();
     return ok;
 #else
-    bool ok = boost::filesystem::create_directory (path.str());
+    bool ok = boost::filesystem::create_directory (pathStr);
     if (ok)
         err.clear();
     else
@@ -317,12 +359,24 @@ Filesystem::create_directory (string_view path, std::string &err)
 bool
 Filesystem::copy (string_view from, string_view to, std::string &err)
 {
+#if defined(_WIN32)
+    // boost internally doesn't use MultiByteToWideChar (CP_UTF8,...
+    // to convert char* to wchar_t* because they do not know the encoding
+    // See boost::filesystem::path.hpp
+    // The only correct way to do this is to do the conversion ourselves
+    std::wstring fromStr = Strutil::utf8_to_utf16(from);
+    std::wstring toStr = Strutil::utf8_to_utf16(to);
+#else
+    std::string fromStr = from.str();
+    std::string toStr = to.str();
+#endif
+    
 #if BOOST_FILESYSTEM_VERSION >= 3
     boost::system::error_code ec;
 # if BOOST_VERSION < 105000
-    boost::filesystem3::copy (from.str(), to.str(), ec);
+    boost::filesystem3::copy (fromStr, toStr, ec);
 # else
-    boost::filesystem::copy (from.str(), to.str(), ec);
+    boost::filesystem::copy (fromStr, toStr, ec);
 # endif
     if (! ec) {
         err.clear();
@@ -341,12 +395,23 @@ Filesystem::copy (string_view from, string_view to, std::string &err)
 bool
 Filesystem::rename (string_view from, string_view to, std::string &err)
 {
+#if defined(_WIN32)
+    // boost internally doesn't use MultiByteToWideChar (CP_UTF8,...
+    // to convert char* to wchar_t* because they do not know the encoding
+    // See boost::filesystem::path.hpp
+    // The only correct way to do this is to do the conversion ourselves
+    std::wstring fromStr = Strutil::utf8_to_utf16(from);
+    std::wstring toStr = Strutil::utf8_to_utf16(to);
+#else
+    std::string fromStr = from.str();
+    std::string toStr = to.str();
+#endif
 #if BOOST_FILESYSTEM_VERSION >= 3
     boost::system::error_code ec;
 # if BOOST_VERSION < 105000
-    boost::filesystem3::rename (from.str(), to.str(), ec);
+    boost::filesystem3::rename (fromStr, toStr, ec);
 # else
-    boost::filesystem::rename (from.str(), to.str(), ec);
+    boost::filesystem::rename (fromStr, toStr, ec);
 # endif
     if (! ec) {
         err.clear();
@@ -365,16 +430,25 @@ Filesystem::rename (string_view from, string_view to, std::string &err)
 bool
 Filesystem::remove (string_view path, std::string &err)
 {
+#if defined(_WIN32)
+    // boost internally doesn't use MultiByteToWideChar (CP_UTF8,...
+    // to convert char* to wchar_t* because they do not know the encoding
+    // See boost::filesystem::path.hpp
+    // The only correct way to do this is to do the conversion ourselves
+    std::wstring pathStr = Strutil::utf8_to_utf16(path);
+#else
+    std::string pathStr = path.str();
+#endif
 #if BOOST_FILESYSTEM_VERSION >= 3
     boost::system::error_code ec;
-    bool ok = boost::filesystem::remove (path.str(), ec);
+    bool ok = boost::filesystem::remove (pathStr, ec);
     if (ok)
         err.clear();
     else
         err = ec.message();
     return ok;
 #else
-    bool ok = boost::filesystem::remove (path.str());
+    bool ok = boost::filesystem::remove (pathStr);
     if (ok)
         err.clear();
     else
@@ -388,16 +462,25 @@ Filesystem::remove (string_view path, std::string &err)
 unsigned long long
 Filesystem::remove_all (string_view path, std::string &err)
 {
+#if defined(_WIN32)
+    // boost internally doesn't use MultiByteToWideChar (CP_UTF8,...
+    // to convert char* to wchar_t* because they do not know the encoding
+    // See boost::filesystem::path.hpp
+    // The only correct way to do this is to do the conversion ourselves
+    std::wstring pathStr = Strutil::utf8_to_utf16(path);
+#else
+    std::string pathStr = path.str();
+#endif
 #if BOOST_FILESYSTEM_VERSION >= 3
     boost::system::error_code ec;
-    unsigned long long n = boost::filesystem::remove_all (path.str(), ec);
+    unsigned long long n = boost::filesystem::remove_all (pathStr, ec);
     if (!ec)
         err.clear();
     else
         err = ec.message();
     return n;
 #else
-    unsigned long long n = boost::filesystem::remove_all (path.str());
+    unsigned long long n = boost::filesystem::remove_all (pathStr);
     err.clear();
     return n;
 #endif
@@ -430,9 +513,18 @@ Filesystem::temp_directory_path()
 std::string
 Filesystem::unique_path (string_view model)
 {
+#if defined(_WIN32)
+    // boost internally doesn't use MultiByteToWideChar (CP_UTF8,...
+    // to convert char* to wchar_t* because they do not know the encoding
+    // See boost::filesystem::path.hpp
+    // The only correct way to do this is to do the conversion ourselves
+    std::wstring modelStr = Strutil::utf8_to_utf16(model);
+#else
+    std::string modelStr = model.str();
+#endif
 #if BOOST_FILESYSTEM_VERSION >= 3
     boost::system::error_code ec;
-    boost::filesystem::path p = boost::filesystem::unique_path (model.str(), ec);
+    boost::filesystem::path p = boost::filesystem::unique_path (modelStr, ec);
     return ec ? std::string() : p.string();
 #elif _MSC_VER
     char buf[TMP_MAX];
@@ -484,13 +576,13 @@ Filesystem::fopen (string_view path, string_view mode)
 }
 
 
-
 void
-Filesystem::open (std::ifstream &stream, string_view path,
+Filesystem::open (OIIO_NAMESPACE::ifstream &stream, string_view path,
                   std::ios_base::openmode mode)
 {
 #ifdef _WIN32
-    // Windows std::ifstream accepts non-standard wchar_t* 
+    // Windows std::ifstream accepts non-standard wchar_t*
+    // On MingW, we use our own OIIO_NAMESPACE::ifstream
     std::wstring wpath = Strutil::utf8_to_utf16(path);
     stream.open (wpath.c_str(), mode);
     stream.seekg (0, std::ios_base::beg); // force seek, otherwise broken
@@ -502,11 +594,12 @@ Filesystem::open (std::ifstream &stream, string_view path,
 
 
 void
-Filesystem::open (std::ofstream &stream, string_view path,
+Filesystem::open (OIIO_NAMESPACE::ofstream &stream, string_view path,
                   std::ios_base::openmode mode)
 {
 #ifdef _WIN32
     // Windows std::ofstream accepts non-standard wchar_t*
+    // On MingW, we use our own OIIO_NAMESPACE::ofstream
     std::wstring wpath = Strutil::utf8_to_utf16 (path);
     stream.open (wpath.c_str(), mode);
 #else
@@ -515,7 +608,6 @@ Filesystem::open (std::ofstream &stream, string_view path,
 }
 
 
-
 /// Read the entire contents of the named file and place it in str,
 /// returning true on success, false on failure.
 bool
@@ -523,13 +615,15 @@ Filesystem::read_text_file (string_view filename, std::string &str)
 {
     // For info on why this is the fastest method:
     // http://insanecoding.blogspot.com/2011/11/how-to-read-in-file-in-c.html
-    std::ifstream in;
+    
+    OIIO_NAMESPACE::ifstream in;
     Filesystem::open (in, filename);
+    
+    
     // N.B. for binary read: open(in, filename, std::ios::in|std::ios::binary);
     if (in) {
         std::ostringstream contents;
         contents << in.rdbuf();
-        in.close ();
         str = contents.str();
         return true;
     }
diff --git a/src/libutil/strutil.cpp b/src/libutil/strutil.cpp
index 954fd61..21e45a8 100644
--- a/src/libutil/strutil.cpp
+++ b/src/libutil/strutil.cpp
@@ -507,8 +507,9 @@ Strutil::utf8_to_utf16 (string_view str)
 {
     std::wstring native;
     
-    native.resize(MultiByteToWideChar (CP_UTF8, 0, str.c_str(), -1, NULL, 0));
-    MultiByteToWideChar (CP_UTF8, 0, str.c_str(), -1, &native[0], (int)native.size());
+    
+    native.resize(MultiByteToWideChar (CP_UTF8, 0, str.c_str(), -1, NULL, 0) -1);
+    MultiByteToWideChar (CP_UTF8, 0, str.c_str(), str.size(), &native[0], (int)native.size());
 
     return native;
 }
diff --git a/src/openexr.imageio/exrinput.cpp b/src/openexr.imageio/exrinput.cpp
index e53067f..bffc399 100644
--- a/src/openexr.imageio/exrinput.cpp
+++ b/src/openexr.imageio/exrinput.cpp
@@ -131,7 +131,7 @@ private:
         }
         return true;
     }
-    std::ifstream ifs;
+    OIIO_NAMESPACE::ifstream ifs;
 };
 
 
diff --git a/src/openexr.imageio/exroutput.cpp b/src/openexr.imageio/exroutput.cpp
index 72f66a5..6cdfe9e 100644
--- a/src/openexr.imageio/exroutput.cpp
+++ b/src/openexr.imageio/exroutput.cpp
@@ -125,7 +125,7 @@ private:
             throw Iex::ErrnoExc ("File output failed.");
         }
     }
-    std::ofstream ofs;
+    OIIO_NAMESPACE::ofstream ofs;
 };
 
 
diff --git a/src/pnm.imageio/pnminput.cpp b/src/pnm.imageio/pnminput.cpp
index 86c16f4..17abebc 100644
--- a/src/pnm.imageio/pnminput.cpp
+++ b/src/pnm.imageio/pnminput.cpp
@@ -32,6 +32,7 @@
 #include <fstream>
 #include <cstdlib>
 
+
 #include "OpenImageIO/filesystem.h"
 #include "OpenImageIO/fmath.h"
 #include "OpenImageIO/imageio.h"
@@ -53,7 +54,7 @@ private:
       P1, P2, P3, P4, P5, P6, Pf, PF
     };
 
-    std::ifstream m_file;
+    OIIO_NAMESPACE::ifstream m_file;
     std::streampos m_header_end_pos; // file position after the header
     std::string m_current_line; ///< Buffer the image pixels
     const char * m_pos;
@@ -82,7 +83,7 @@ OIIO_PLUGIN_EXPORTS_END
 
 
 inline bool
-nextLine (std::ifstream &file, std::string &current_line, const char * &pos) 
+nextLine (std::istream &file, std::string &current_line, const char * &pos)
 {   
     if (!file.good())
         return false;
@@ -96,7 +97,7 @@ nextLine (std::ifstream &file, std::string &current_line, const char * &pos)
 
 
 inline const char * 
-nextToken (std::ifstream &file, std::string &current_line, const char * &pos)
+nextToken (std::istream &file, std::string &current_line, const char * &pos)
 {		
     while (1) {
         while (isspace (*pos)) 
@@ -112,7 +113,7 @@ nextToken (std::ifstream &file, std::string &current_line, const char * &pos)
 
 
 inline const char *
-skipComments (std::ifstream &file, std::string &current_line, 
+skipComments (std::istream &file, std::string &current_line,
               const char * & pos, char comment = '#')
 {		
     while (1) {
@@ -128,7 +129,7 @@ skipComments (std::ifstream &file, std::string &current_line,
 
 
 inline bool
-nextVal (std::ifstream & file, std::string &current_line,
+nextVal (std::istream & file, std::string &current_line,
          const char * &pos, int &val, char comment = '#')
 {
     skipComments (file, current_line, pos, comment);
@@ -152,7 +153,7 @@ invert (const T *read, T *write, imagesize_t nvals)
 
 template <class T> 
 inline bool 
-ascii_to_raw (std::ifstream &file, std::string &current_line, const char * &pos,
+ascii_to_raw (std::istream &file, std::string &current_line, const char * &pos,
               T *write, imagesize_t nvals, T max)
 {
     if (max)
@@ -248,7 +249,7 @@ PNMInput::read_file_scanline (void * data, int y)
 
     std::vector<unsigned char> buf;
     bool good = true;
-    if (!m_file.is_open())
+    if (!m_file)
         return false;
     int nsamples = m_spec.width * m_spec.nchannels;
 
@@ -276,17 +277,17 @@ PNMInput::read_file_scanline (void * data, int y)
     switch (m_pnm_type) {
         //Ascii 
         case P1:
-            good &= ascii_to_raw (m_file, m_current_line, m_pos, (unsigned char *) data, 
+            good &= ascii_to_raw (m_file, m_current_line, m_pos, (unsigned char *) data,
                                   nsamples, (unsigned char)m_max_val);
             invert ((unsigned char *)data, (unsigned char *)data, nsamples); 
             break;
         case P2:
         case P3:
             if (m_max_val > std::numeric_limits<unsigned char>::max())
-                good &= ascii_to_raw (m_file, m_current_line, m_pos, (unsigned short *) data, 
+                good &= ascii_to_raw (m_file, m_current_line, m_pos, (unsigned short *) data,
                                       nsamples, (unsigned short)m_max_val);
             else 
-                good &= ascii_to_raw (m_file, m_current_line, m_pos, (unsigned char *) data, 
+                good &= ascii_to_raw (m_file, m_current_line, m_pos, (unsigned char *) data,
                                       nsamples, (unsigned char)m_max_val);
             break;
         //Raw
@@ -328,7 +329,7 @@ PNMInput::read_file_header ()
 
     unsigned int width, height;
     char c;
-    if (!m_file.is_open())
+    if (!m_file)
         return false;
   
     //MagicNumber
@@ -444,9 +445,8 @@ bool
 PNMInput::open (const std::string &name, ImageSpec &newspec)
 {
     close(); //close previously opened file
-
     Filesystem::open (m_file, name, std::ios::in|std::ios::binary);
-
+    
     m_current_line = "";
     m_pos = m_current_line.c_str();
 
@@ -462,8 +462,7 @@ PNMInput::open (const std::string &name, ImageSpec &newspec)
 bool
 PNMInput::close ()
 {
-    if (m_file.is_open())
-        m_file.close();
+    m_file.close();
     return true;
 }
 
diff --git a/src/pnm.imageio/pnmoutput.cpp b/src/pnm.imageio/pnmoutput.cpp
index 07735bc..e9866bb 100644
--- a/src/pnm.imageio/pnmoutput.cpp
+++ b/src/pnm.imageio/pnmoutput.cpp
@@ -51,7 +51,7 @@ public:
 
 private:
     std::string m_filename;           ///< Stash the filename
-    std::ofstream m_file;
+    OIIO_NAMESPACE::ofstream m_file;
     unsigned int m_max_val, m_pnm_type;
     unsigned int m_dither;
     std::vector<unsigned char> m_scratch;
@@ -188,10 +188,11 @@ PNMOutput::open (const std::string &name, const ImageSpec &userspec,
         m_pnm_type -= 3;
         Filesystem::open (m_file, name);
     }
-    else
+    else {
         Filesystem::open (m_file, name, std::ios::out|std::ios::binary);
+    }
 
-    if (!m_file.is_open())
+    if (!m_file)
        return false;
 
     m_max_val = (1 << bits_per_sample) - 1;
@@ -214,7 +215,7 @@ PNMOutput::open (const std::string &name, const ImageSpec &userspec,
 bool
 PNMOutput::close ()
 {
-    if (! m_file.is_open()) {   // already closed
+    if (! m_file) {   // already closed
         return true;
     }
 
@@ -237,7 +238,7 @@ bool
 PNMOutput::write_scanline (int y, int z, TypeDesc format,
         const void *data, stride_t xstride)
 {
-    if (!m_file.is_open())
+    if (!m_file)
         return false;
     if (z)
         return false;
diff --git a/src/psd.imageio/psdinput.cpp b/src/psd.imageio/psdinput.cpp
index b2c5770..e8f4d3b 100644
--- a/src/psd.imageio/psdinput.cpp
+++ b/src/psd.imageio/psdinput.cpp
@@ -196,7 +196,7 @@ private:
     };
 
     std::string m_filename;
-    std::ifstream m_file;
+    OIIO_NAMESPACE::ifstream m_file;
     //Current subimage
     int m_subimage;
     //Subimage count (1 + layer count)
@@ -543,8 +543,10 @@ bool
 PSDInput::open (const std::string &name, ImageSpec &newspec)
 {
     m_filename = name;
+    
     Filesystem::open (m_file, name, std::ios::binary);
-    if (!m_file.is_open ()) {
+    
+    if (!m_file) {
         error ("\"%s\": failed to open file", name.c_str());
         return false;
     }
@@ -759,7 +761,7 @@ void
 PSDInput::init ()
 {
     m_filename.clear ();
-    m_file.close ();
+    m_file.close();
     m_subimage = -1;
     m_subimage_count = 0;
     m_specs.clear ();
@@ -928,7 +930,7 @@ PSDInput::load_resources ()
     ImageResourceMap resources;
     std::streampos begin = m_file.tellg ();
     std::streampos end = begin + (std::streampos)length;
-    while (m_file && m_file.tellg () < end) {
+    while (!m_file.fail() && m_file.tellg () < end) {
         if (!read_resource (block) || !validate_resource (block))
             return false;
 
